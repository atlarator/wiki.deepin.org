---
title: Linux下如何做到一个文件即可读写,又只读
description: 
published: true
date: 2023-06-14T08:52:59.169Z
tags: 
editor: markdown
dateCreated: 2023-06-14T08:51:19.223Z
---

在 Linux 运维过程中，经常会遇到某个应用的存储目录跑满，提前又没有做任何规划，目录或磁盘无法扩容，这个时候，我们常用的解决方法是做软链接，通过 ln，将原先存储的目录软链接到另外大的磁盘中的目录下，以此达到目的。

软链的弊端就是，多层软链之后，会被绕晕，很容易造成误操作，今天再介绍一种方法

### **mount --bind**

mount 命令运维小伙伴应该很熟悉，不做过多介绍

先来看下 man 里面的介绍

![2023-6-14_99041.png](/2023-6-14_99041.png)

通过 mount --bind 可以将文件目录结构重新挂载，连接两个目录，它是将前一个目录挂载到后一个目录上，所有对后一个目录的访问其实都是对前一个目录的访问
例子
通过例子看下，分别创建两个不同的目录，并在两个不同的目录下创建不同的文件

![2023-6-14_40290.png](/2023-6-14_40290.png)

查看文件的 inode

![2023-6-14_78355.png](/2023-6-14_78355.png)

通过 mount --bind 将 test1 挂载到 test2 上，重新查看 inode 和目录下内容

![2023-6-14_33474.png](/2023-6-14_33474.png)

可以看到，inode 号和文件，都是 test1 的
然后对 test2 目录下的文件访问修改，实际上改动的就是 test1 目录，我们测试下，在 test2 目录创建文件

![2023-6-14_7708.png](/2023-6-14_7708.png)

然后接触 mount 之后，我们再查看下两个目录下的内容

![2023-6-14_8983.png](/2023-6-14_8983.png)

可以看到，test1 目录保持修改后的状态，test2 目录文件仍然存在，且保持原来的不变

**原理**

以 mount --bind test1 test2 为例，当 mount --bind 命令执行后，Linux 将会把被挂载目录的目录项（**也就是该目录文件的 block，记录了下级目录的信息**）屏蔽，即 test2 的下级路径被隐藏起来了（**注意，只是隐藏不是删除，数据都没有改变，只是访问不到了**）。

同时，内核将挂载目录（test1）的目录项记录在内存里的一个 s_root 对象里，在 mount 命令执行时，VFS 会创建一个 vfsmount 对象，这个对象里包含了整个文件系统所有的 mount 信息，其中也会包括本次 mount 中的信息，这个对象是一个 HASH 值对应表（HASH 值通过对路径字符串的计算得来），表里就有 /test1 到 /test2 两个目录的 HASH 值对应关系

命令执行完后，当访问 /test2 下的文件时，系统会告知 /test2 的目录项被屏蔽掉了，自动转到内存里找 VFS，通过 vfsmount 了解到 /test2 和 /test1 的对应关系，从而读取到 /test1 的 inode，这样在 /test2 下读到的全是 /test1 目录下的文件

### **注意**

两个目录的对应关系是存在于内存中的，一旦重启，挂载关系就没有了，所以需要将挂载关系，写入 / etc/fstab 中

### **高级用法**

**临时配置文件读取测试**

. 有些应用场景下，需要修改配置文件进行测试，但是又不能影响正在运行中的业务，在没有把握的情况下，不愿意直接修改原有配置文件的话，我们可以通过在 / tmp 等目录，写一个测试的配置文件，通过 mount --bind 的方式挂载到配置文件读取目录，运行程序读取该临时配置文件，测试完成后，只需要 umount，不影响原来的配置

**只读挂载**

. 在一些场景下，比如需要给开发人员查看一些配置的权限，但是又不允许它们修改配置的情况下，可以通过 mount --bind,ro 挂载一个只读目录，原目录可写，挂载出来的目录只读，只需要将只读目录权限给开发人员即可

以上就是 mount --bind 的简单介绍，更多使用方法，各位小伙伴可以自行尝试。